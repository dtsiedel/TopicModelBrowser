Topic Model Browser
by Drew Siedel, Alexander Van Heest, Lena McDonnell, Rachel McCoog
Advisor: Professor Eric Baumer (Lehigh DAS Lab)

The Topic Model Browser is a visualization tool for understanding and exploring topic models. A topic model is a clustering of words from an unlabeled corpus into discrete topics, as defined by co-occurrence of words. Social scientists frequently encounter large corpora of such documents, and topic modeling is a great solution for gaining understanding of corpora with many thousands of documents. This browser allows non-technical users to interpret and utilize the results of a topic model on any text dataset.

The project uses R (with the RMallet package) to run a topic model on a dataset of ~38,000 blog posts made by family members of autistic children. A Node.js server processes the data and sends it to the client, where we use the Javascript library D3 to create our visualizations.

Although this particular instantiation operates on the blog dataset, the tool is designed to be generically applied to any topic modeling result, regardless of the content.

[Check it out in action](https://www.youtube.com/watch?v=eOl93rVenhs, "Video Link")


## Content Summaries

#### `README.md`
> This file.

#### `filtered_merged_file.json`
> Not in the Git repo, fetch it from the DAS Lab server. Contains the scraped texts in a [JSON](https://www.w3schools.com/js/js_json_intro.asp) format. This file is read in by the server, and is used to serve the full text of the documents when the server requests it using [Ajax](https://www.w3schools.com/xml/ajax_intro.asp).

#### `node_modules`
> Contains the project's dependencies, as managed by [npm](https://www.w3schools.com/nodejs/nodejs_npm.asp). Not in the Git repo, but will be automatically generated by running `npm install` from the root of the project. 

#### `package-lock.json`
> Managed automatically by npm as long as you use the -S flag, should not need to manually edit this. 

#### `package.json`
> Also managed automatically by npm as long as you use the -S flag, should not need to manually edit this. 

#### `server.js`
> The server-side Javascript of our application, running [Node.js](https://nodejs.org/en/). If you are working locally on your machine, start a local server by running `node server.js`.  This will make the application available at `localhost:8000`. If you are on the server, use `sudo forever start server.js` to make the application available at `http://das-lab.org:8000`. You can see if it is running with `sudo forever list`, and stop it with `sudo forever stop 0` (or whatever the index shown by `list` is).

#### `public/`
> The directory containing all of the files that are accessible directly by the client. These are listed below:

* `TODO.txt` - a rough approximation of work in progress or in the pipeline. 
* `agg_data.csv` - data that shows the topic breakdown for each combination of `aggregate_type` and `aggregate_value`. For example, the specific example included in the Git repo has the topic values for each blog in the autism blog dataset.
* `agg_multiple.js` - the Javascript file that displays a force-directed layout of a set of values for a specific aggregate - for example, of a number of different blogs. Hash prefix is m.
* `agg_single.js` - the Javascript file that displays a donut chart of the topic breakdown of a single value for a specific aggregate - for example, of a single blog. Hash prefix is a.
* `bar.js` - the Javascript file that displays side-by-side stacked bar graphs representing two individual documents from the corpus. Hash prefix is b.
* `corpus.js` - the Javascript file that displays our "home view" - a chord diagram showing the relations between all of the topics from the topic model. No hash. 
* `donut.js` - the Javascript file that displays a single donut graph representing the topic breakdown of an individual document from the corpus. Hash prefix is d. 
* `entry.js` - the Javascript file that is run first when entering the application. Parses the [hash](https://www.w3schools.com/jsref/prop_loc_hash.asp) to determine whether to go to the corpus view, or to another one of the views. 
* `favicon.png` - the small DAS Lab logo displayed as our application's icon in your browser tab. 
* `index.html` - the HTML for the project. Effectively a stub, as most of our HTML is created dynamically using [D3.js](https://d3js.org/). Its only critical function is loading our scripts and providing the basic skeleton to which we append our visualizations.
* `library.js` - the Javascript file containing functions that are used by multiple different views. This allows for code modularity and reuse between views. Note that the load order in `index.html` is important - the other views will fail without including this first.
* `nodes.js` - the Javascript file that displays a force-directed layout of a set of documents from our corpus. Hash prefix is n.
* `ribbon_counts.csv` - a CSV file containing the counts of how many values link each topic to each other topic. Will have the shape N x N, where N is the number of topics. Is not included in the Git repo, fetch it from the server. A Javascript function exists (`getRibbonCounts()`)  to compute this, but it may be wise to rework this into a Python script since it is precomputed and stored on the server.
*  `ribbon_data.txt` - a specifically formatted text file that contains a list of every document that is on every chord in the corpus view. The shape is, again, N x N where N is the number of topics. However, each entry is a comma-separated list of document indices. As with the previous file, a Javascript function exists (`getRibbonData()`)  to compute this, but it may be wise to rework this into a Python script since it is precomputed and stored on the server.
* `spectrum.js` - the Javascript file that displays a distribution between two topics, where each point is a single document that is about both topics. Hash prefix is s. 
* `styles.css` - a single file containing **all** of the (poorly-organized) styles for the project. Could stand to be organized or split into a few files, but it's not strictly necessary. 
* `topic.js` -  the Javascript file that displays a summary of a single topic, as defined by its words and documents. Hash prefix is t.
* `topic_frame.csv` - the most important data file. Contains one row for each document, where each row is a set of N decimal values, where N is the number of topics. Each value represents the relevance of the given topic to the given document. It also contains one row per each aggregate type, indicating which aggregate value belongs to a given entry (for example, which blog a particular post is from). 

## Other Important Information

#### The Call Stack
> The application maintains a history, just like most web browsers do. To do so, it keeps a call stack tracking each of the views that have been visited thus far, as well as their parameters. This allows the application to transition to a previous view at any point. The call stack is accessible in the `call_stack` variable, and can be seen visually by long-clicking the "Back to Previous View" button. The target values for each view are passed in with the same format that is used in the call stack, so examining this can help identify problems with passing data to views. 

#### Transitioning Between Views
>All transitions between views should be performed using the `goTo()` function found in `library.js`. This function takes four parameters: `source`  is the current view, `target` is the view you want to go to, `parameters` is the set of arguments you want to pass to the view, and `returning` is a flag set to true when the function is used to rewind the call stack. When calling `goTo()`, the "cleanup" function of `source` is called, and then the "main" function of `target` is called with the given parameters. Doing it this way ensures that the call stack is up to date, and that each view is modularly responsible for cleaning up any elements it puts on the screen. 

#### How To Add A New View
* add a new js file for your view
* include the js file in `index.html`
* add the new page name to the `pages` enum in `library.js`
* add a string representation in `prettify_one_entry()` in `library.js`
* create a hash representation, and add it to the switch statement in `entry.js`
* implement a main function and cleanup function for your view
* update the `goTo()` function in `library.js` to point to your file's main and cleanup functions


